# 8086汇编

## debug工具：

R命令查看、改变CPU寄存器的内容

D命令查看内存中的内容

E命令改写内存中的内容

U命令将内存中的机器指令翻译成汇编指令

T命令执行CS:IP指向的一条机器指令

A命令以汇编指令的格式在内存中写入一条机器指令

g：执行程序到指定的ip值

p：执行到循环结束、执行完最后一条语句

## 寄存器

AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW

共14个。8086CPU的所有寄存器都是16位的。8086CPU是16位结构，有16根数据线。

### 通用寄存器：

#### AX:

##### ah用来传递内部子程序编号：

存放BOIS和DOS中断例程的子程序编号；

    mov ax, 4c00h
    int 21h

#### CX:

程序启动时默认存放程序的大小

##### 存放loop执行的次数

```asm6502
    mov cx, 11
s:  add ax, ax
    loop s
```

每执行完一次循环，CX的值都会减1，当CX的值等于0时循环退出；

对于多重循环，进入内层循环前，先将外层循环的CX值压栈，出了内层循环再出栈到CX;

### 段寄存器：

CS、SS、DS、ES

不支持将数据直接送入段寄存器，需要经过通用寄存器

    mov bx,1000H
    mov ds,bx
    mov [0],al

#### DS：数据段

##### DS和[address]

8086CPU中的DS寄存器，通常用来存放要访问数据的段地址。 [...]则表示一个内存单元，如 [1] 为内存单元： DS:1

#### 段前缀：

必须使用段前缀，否则mov al,[0]和mov al,0 等价，下面第二种方式只能用于ds

    mov ax,ds:[bx]
    或
    mov bx,0
    mov al,[bx]

#### CS：代码段

CS：代码段寄存器 IP：指令指针寄存器

#### SS：栈段

**任意时刻，SS:SP 指向栈顶元素。** push和pop指令执行时，CPU从 SS 和 SP 中得到栈顶的地址。

栈，LIFO（Last In First Out，后进先出）。8086CPU中，入栈时，栈顶从高地址向低地址方向增长。

##### push 指令

按两步执行：

    SP=SP-2
    push的参数存入SP指向的内存

##### pop 指令：

按两步执行：

```
SP=SP-2
push的参数存入SP指向的内存
```

借助push和pop可以实现内存数据的交换

### SI和DI:

si 和 di 是8086CPU 中和 bx 功能相近的寄存器，si 和 di 不能够分成两个 8 位寄存器来使用。

我们用 [bx(si 或 di)] 和 [bx(si 或 di) + idata] 的方式来指明一个内存单元，我们还可以用更为灵活的方式：[bx + si] 和 [bx + di]，[bx + si + idata] 和 [bx + di + idata]

而 `mov ax, [bx + si]` 还可以写为 `mov ax, [bx][si]` ，且以下这几种都和 `mov ax, [bx + si + 200]`等价：

    mov ax, [200+bx+si]
    mov ax, [bx+200+si]
    mov ax, 200[bx][si]
    mov ax, [bx+200+si]
    mov ax, [bx].200+[si]
    mov ax, [bx][si].200

#### bx、si、di 和 bp

8086CPU中，只有着4个寄存器可以用在[...]中进行内存单元的寻址。在[...]中；

这4个寄存器可以单个出现，或者以4种组合出现：bx和si、bx和di、bp和si、bp和di；

在[...]中出现bp，段地址没有特地指明，段地址就是SS中；

### 标志寄存器flag：

CF(0):进位标志位（Carry Flag）:对于无符号数,记录了最高位的进位或者借位

PF(2):奇偶标志位（Parity Flag）:运算结果中1的个数为偶数则置1

AF(4):辅助进位标志位Auxiliary Carry Flag）

ZF(6):零标志位（Zero Flag）:上一次计算的结果为零则标志位置1

SF(7):符号标志位（Sign Flag）:计算结果是有符号数则置1

TF(8):调试标志位（Trace Flag）:单步调试则置1

IF(9):中断允许标志位（Interrupt Flag）

DF(10):方向标志位（Direction Flag）:DF=0，每次操作后，si、di递增;DF=1，每次操作后，si、di递减

OF(11):溢出标志位（Over Flow Flag）:有符号运算的时候，如果结果超过了机器所能表示的范围。注：无符号数的叫进位

#### 指令对标志寄存器的影响：

传送指令不会影响标志寄存器的值

#### pushf 和 popf

pushf 和 popf 为直接访问标志寄存器提供了一种方法。

pushf：将标志寄存器的值压栈。 popf：从栈中弹出数据，送入标志寄存器。

## 组织数据：

### 数据、代码、栈放入一个段中

### 数据、代码、栈放入不同的段

### 数据标号：

以下代码：

    assume cs:code
    
    code segment
        a: db 1, 2, 3, 4, 5, 6, 7, 8
        b: dw 0

写为：有：仅表示地址的地址标号；没有：，同时密松属内存地址和单元长度的标号。a表示code:0

    assume cs:code
    
    code segment
        a db 1, 2, 3, 4, 5, 6, 7, 8
        b dw 0

## 汇编指令：

### 处理机控制指令：

###### cld：将标志寄存器的DF位置0

###### std：将标志寄存器的DF置1

###### nop:占用一个字节的`No Operation`

### 数值运算：

##### inc：内存中的值加1

    inc word ptr [bx]
    inc word ptr ds:[0]
    inc byte ptr [bx]
    inc byte ptr ds:[0]

##### adc：带进位加法

会加上CF位上记录的进位值

##### dec：内存中的值减1

##### sub：借位减法指令

操作对象1 = 操作对象1 - 操作对象2 -CF

##### div除法指令：

除数有8位和16位两种，在一个reg或内存单元中

###### 被除数：

除数是8位，，被除数放在AX中。AL中存储上，AH中存储余数

除数是16位，DX存放高16位，AX存放低16位。AX存储商，DX存储余数

##### mul乘法指令：

两个相乘的数，要么都是8位，要么都是16位

###### 乘数：

8位默认放在AL中，结果放在AX中

16位默认放在AX中，结果高16位放DX，低16位放AX

### 逻辑运算：

##### and：逻辑与

##### or：逻辑或

##### cmp指令：

比较指令，相当于减法指令，只影响标志寄存器，不保存结果

### 逻辑移位：

#### shl：

将一个寄存器或内存中的数据向左移动位，将最后移出的一位设置到CF中，最低位以0补充

#### shr：

将一个寄存器或内存中的数据向右移动位，将最后移出的一位设置到CF中，最高位以0补充

### 指令处理的数据长度：

##### 指令中寄存器名指定

```shell
mov ax, 1
mov al, 0
```

##### 显示指定

```shell
mov word ptr ds:[0], 1
mov byte ptr ds:[0], 1
```

##### 默认指定

`push`和`pop`都是对字进行操作

### 编译器识别的伪指令：

### 数据类型：

db：define byte，定义字节型数据 

dw：define word，定义字型数据 

dd：define double word，定义双字型数据

### dup：

```shell
db 3 dup (0)
db 3 dup (1, 2, 3)
```

### offset:

取得标号的偏移地址。

### 转移指令：

可以修改IP，或同时修改CS和IP的指令称为转移指令。

### 转移行为分类：

###### 段内转移：

只修改IP。如：jmp ax

###### 段间转移：

同时修改CS和IP。如：jmp 1000:0

###### 短转移：

IP的范围-128~127

###### 近转移：

IP的范围-32768~32767

### 转移指令分类：

无条件转移：jmp

条件转移指令：

循环指令

过程

中断

#### jmp：

##### 段内短转移：

`jmp short 标号`

##### 段内近转移：

`jmp near ptr 标号`

##### 段间转移：

`jmp far ptr 标号`

##### jmp 寄存器

###### jmp word ptr 内存单元地址

段内转移

###### jmp dword ptr 内存单元地址

段间转移，高地址存放段地址，低地址存放偏移地址

#### 条件转移：

所有的条件转移都是短转移

##### jcxz：

如果cx=0则转移：`jcxz 标号`

大部分条件转移指令都检测标志寄存器的相关标志位，根据检测结果来决定是否修改IP;

| 指令  | 含义     | 检测        |
| --- | ------ | --------- |
| je  | 等于则转移  | zf=1      |
| jne | 不等于则转移 | zf=0      |
| jb  | 低于则转移  | cf=1      |
| jnb | 不低于则转移 | cf=0      |
| ja  | 高于则转移  | cf=0且zf=0 |
| jna | 不高于则转移 | cf=1且zf=1 |
|     |        |           |
|     |        |           |

#### loop：

所有的循环指令都是短转移：`loop 标号`

#### call和ret：

call 和 ret 指令都是转移指令，它们都修改 IP ，或同时修改 CS 和 IP。它们经常被共同来实现子程序的设计。

##### ret指令

用栈中的数据，修改IP的内容，从而实现近转移；

    1、(IP)=((ss)*16+(sp))
    2、(sp)=(sp)+2
    相当于
    pop IP

##### retf指令

用栈中的数据，修改CS和IP的内容，从而实现远转移；

    1、(IP)=((ss)*16+(sp))
    2、(sp)=(sp)+2
    1、(CS)=((ss)*16+(sp))
    2、(sp)=(sp)+2
    相当于
    pop IP
    pop CS

##### call指令：

###### call 标号：

不能实现段转移，是近转移，相当于：

    push IP
    jmp near ptr 标号

###### call far ptr 标号：

实现段间转移，相当于：

    push CS
    push IP
    jmp near ptr 标号

###### call 寄存器：

    push IP
    jmp 16位寄存器

###### call 内存单元：

`call word ptr 内存单元地址 `相当于：

    push IP
    jmp word ptr 内存单元地址

`call dword ptr 内存单元地址` 相当于：

```
push CS
push IP
jmp dword ptr 内存单元地址
```

#### int 和 iret

int 是 interrupt 的意思，格式为 int n，n 为中断类型码，它的功能是引发中断过程。

可以在程序中使用 int 指令调用任何一个中断的处理程序。可见其与 call 指令类似，都是调用一段程序。

call与ret配套使用，int和iret配套使用；

### 串处理指令：

### movsb：

以字节为单位进行传送

```shell
mov es:[di], byte ptr ds:[si]
```

### movsw：

以字为单位进行传送

```shell
mov es:[di], word ptr ds:[si]
```

### 传送指令：

### rep:

重复指令 `rep movsb`相当于:

    s:movsb
      loop s 

### cld 和 std

由于 flag 的 df 位决定着串传送指令执行后，si 和 di 改变的方向，所以CPU设置了 cld 和 std 指令：

cld 指令：将标志寄存器的 df 位 置0； std 指令：将标志寄存器的 df 位 置1；

### sti 和 cli

8086CPU 提供的设置标志寄存器的 IF 位的指令：

sti：设置 IF=1； cli：设置 IF=0；

## 端口访问指令：

## 中断：

任何一个通用的 CPU 比如 8086，都具备这种能力：在执行完当前正在执行的指令之后，检测到从 CPU 外部发送过来的或内部产生的一种特殊信息，并且可以立刻对所接收到的信息进行处理。

这种特殊的信息就被称为 中断信息。中断的意思是，CPU 不再接着向下执行，而是转去处理中断信息。

中断信息可以来自于 CPU 的内部和外部。

### 内部中断：

以下四种情况，产生相应的中断信息：

除法错误   类型码0

单步执行   类型码1

指定into指令    类型码4

执行int指令

### 中断类型码

中断信息必须包含识别来源的编码。8086 CPU 用称为中断类型码的数据来标识中断信息的来源。

### 中断向量表 与 中断处理程序

中断向量表在内存中存放，对于 8086PC 机，存于内存地址0处（0000:0000 ~ 0000:03FF）。

中断向量：中断处理程序的入口地址（8086CPU中，这个入口地址包括段地址和偏移地址，所以一个表项两字，高地址字存放段地址，低地址字存放偏移地址）；

中断向量表：中断向量的列表（即中断处理程序入口地址的列表）；

中断处理程序：用来处理中断信息的程序（通过中断类型码来从中断向量表中查找，从而定位中断处理程序，中断处理程序由程序员编写）

### 中断过程

用中断类型码找到中断向量，并用它设置 CS 和 IP，这个工作是 CPU 的硬件自动完成的。CPU 硬件完成这个工作的过程被称为中断过程。

    1、取得中断类型码N；
    2、pushf
    3、TF=0, IF=0
    4、push CS
    5、push IP
    6、(IP)=(N*4),(CS)=(N*4+2)

### 中断处理程序 和 iret 指令

中断处理程序常规步骤：

    1、保存用到的寄存器
    2、处理中断
    3、恢复用到的寄存器
    4、用iret指令返回

iret通常和硬件自动完成的中断过程配合使用。

    pop IP
    pop CS
    popf

### 单步中断：

单步中断过程，CPU每执行完一条指令后，如果检测到标志寄存器的TF为1，则产生单步中断。标志寄存器入栈以后，TF位被置为0；

    1、取得中断类型码1
    2、标志寄存器入栈，TF、IF设置为0
    3、CS、IP入栈
    4、(IP)=(1*4),(CS)=(1*4+2)

### 响应中断的特殊情况

有的特殊情况下，执行完当前指令后即使发生中断也不会响应。

最典型的比如 对 ss 寄存器操作，向 ss 寄存器传入数据，ss:sp 指向栈顶，所以对 ss 和 sp 的设置应该连续完成：设置ss和sp的指令应该连续，因为这两条指令中间，CPU不会响应中断。

### BOIS和DOS所提供的中断例程：

1、开机后，CPU一加电，初始化CS:IP=0FFFFH:0，自动执行此地址的跳转指令，CPU执行此跳转指令到BOIS中的硬件系统检测和初始化程序

2、初始化程序将建立BOIS所支持的中断向量，即将BOIS提供的中断例程的入口地址登记在中断向量表中

3、硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。从此将计算机交由操作系统控制

4、DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量

### 外中断

外设的输入是送入相关的接口芯片的端口中（不是直接送入内存和CPU）；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。

CPU还可以向外设输出控制命令，这些命令也是先送到相关芯片的端口中，再由相关芯片根据命令对外设实施控制。

即CPU通过端口和外部设备进行联系。比较典型的外设比如键盘和显示器。

#### 可屏蔽分类：

即CPU可以不响应的外中断。当标志寄存器的IF=1，在CPU执行完当前指令后响应中断，引发中断过程；如果IF=0,则不响应可屏蔽中断。

#### 不可屏蔽中断：

即CPU可以不响应的外中断。在CPU执行完当前指令后立即响应中断，引发中断过程。中断类型码固定为2.

    1、标志寄存器入栈，IF=0,TF=0
    2、CS、IP入栈
    3、(IP) = 8,(CS)=(0AH)

## 补充

1. 在汇编源程序中，数据不能以字母开头，所以要在前面加0. 比如 “A000h” 要写为 “0A000h”。（P104）
2. debug中可以用p命令来将循环一次执行完，或者用g命令来直接执行到某处。
3. 在汇编程序中，我们可以用 '...' 的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的 ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）码（小写字母的ASCII码比大写字母的ASCII码值大 32 即 20H）。 比如 `db 'unIX'` 相当于 `db 75H,6EH,49H,58H`，后者分别是字母unIX的ASCII码。
4. 汇编语言中用3个概念来表达数据的位置：  
   i. 对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），在汇编语言中称为：立即数（idata），在汇编指令中直接给出。  
   ii. 对于指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。  
   iii. 对于指令要处理的数据在内存中，在汇编指令中可用 [X] 的格式给出 EA（偏移地址），SA（段地址）在某个寄存器中。存放段地址的寄存器可以是默认的（ds或者ss）也可以是显式地给出。
5. “-”是编译器识别的运算符号，编译器可以用它来进行两个常数的减法。（P245）比如`mov ax 8-4`
6. bx （以及无寄存器的情况） 的默认段地址为 ds，bp 则为 ss，若 [] 中有寄存器，则必有 bx 或者 bp （作为基址）（见笔记 bx、si、di 和 bp 一节）
7. CMOS RAM 中存储的时间信息：
