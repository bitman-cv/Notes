### hash索引：

实现：

优点：

1、支持随机查找，访问，速度快；

2、一个简单的实现，内存中存储 key:val偏移。追加写入日志文件 key:val偏移，在多个日志文件段压缩时将旧数据删除，只保留新数据；

缺点：

1、键必须能够放到内存中，因为涉及到大量的随机访问IO；

2、占内存，一般经验，当hash桶使用数量大于2/3时，就需要扩容；在磁盘上扩容耗时严重；并且散列冲突代价很高；

3、范围查询效率低，必须全表扫描；

### 排序字符串表（sort string table）：

思想同LSM（日志结构合并树Log Struct Merge Tree）

实现：

1、在磁盘上可以使用B树；

2、内存中可以使用红黑树等平衡树，当内存表的容量大于阈值，就将内存数据写入磁盘；

3、为了防止系统崩溃导致数据丢失，可以维护一个日志文件，在内存表数据写入磁盘后日志文件被丢弃；

4、读取时，首先在内存表中查找，找不到以后在最近的文件中查找，磁盘文件可以进行合并，丢弃已被覆盖或者删除的值；

优点：

1、合并段时操作更简单，跟归并排序类似；

2、指定键查找更快，无需遍历所有数据，只需从最近的键开始遍历；

3、将记录分组到块，在写入磁盘前进行压缩，压缩后的块中所有条目都指向压缩块的开始处；

性能优化：

1、为了避免查找不存在的键时需要先遍历内存表，再查找磁盘文件到最旧的磁盘文件，耗时久的问题，在内存中采用布隆过滤器（采用bit向量作为数据结构，多个hash函数计算出不同的bit置1,。查询时可以肯定某个元素不存在或者可能存在）；

### B树：

实现：

1、多叉树

2、数据库中的节点一般分解成固定大小的块（4K），为了一次性读取或写入一个页面；

3、每个页面都可以使用地址或者位置标示，允许一个页面引用另外一个页面，最后构建成一个页面树；

4、根页面包含几个键和对子页面的应用，在索引中查找一个键时从根页面开始；

### LSM树：

优点：

1、B树至少两次写入一段数据（预写入日志、树页面本身）。写入数据时对磁盘的多次写入称为写放大；

2、LSM树通常能够比B树支持更高的吞吐量；

缺点：

1、压缩过程可能干扰正在进行的读写操作。因为要分出磁盘操作完成压缩。

2、每个键可能存储在多个文件中，导致对于事物的支持不如B树。B树每个键只有一份，方便在键范围上加锁；

### 其他索引：

除了主键唯一索引，还可以创建二级非唯一索引；

#### 值存储在索引中：

实际存储数据行的地方称为堆文件，避免因存在多个二级索引时引起数据复制；
